import { BundleError } from './bundle_error.js';
export const mergeDeclarations = (tomlDeclarations, userFunctionsConfig, internalFunctionsConfig, deployConfigDeclarations, _featureFlags = {}) => {
    const functionsVisited = new Set();
    const declarations = [
        // INTEGRATIONS
        // 1. Declarations from the integrations deploy config
        ...getDeclarationsFromInput(deployConfigDeclarations, internalFunctionsConfig, functionsVisited),
        // 2. Declarations from the integrations ISC
        ...createDeclarationsFromFunctionConfigs(internalFunctionsConfig, functionsVisited),
        // USER
        // 3. Declarations from the users toml config
        ...getDeclarationsFromInput(tomlDeclarations, userFunctionsConfig, functionsVisited),
        // 4. Declarations from the users ISC
        ...createDeclarationsFromFunctionConfigs(userFunctionsConfig, functionsVisited),
    ];
    return declarations;
};
const getDeclarationsFromInput = (inputDeclarations, functionConfigs, functionsVisited) => {
    var _a, _b;
    const declarations = [];
    // For any declaration for which we also have a function configuration object,
    // we replace the path because that object takes precedence.
    for (const declaration of inputDeclarations) {
        const config = functionConfigs[declaration.function];
        if (!config) {
            // If no config is found, add the declaration as is.
            declarations.push(declaration);
        }
        else if ('pattern' in config && ((_a = config.pattern) === null || _a === void 0 ? void 0 : _a.length)) {
            // If we have a pattern specified as either a string or non-empty array,
            // create a declaration for each pattern.
            const patterns = Array.isArray(config.pattern) ? config.pattern : [config.pattern];
            patterns.forEach((pattern) => {
                declarations.push({ ...declaration, cache: config.cache, pattern });
            });
        }
        else if ('path' in config && ((_b = config.path) === null || _b === void 0 ? void 0 : _b.length)) {
            // If we have a path specified as either a string or non-empty array,
            // create a declaration for each path.
            const paths = Array.isArray(config.path) ? config.path : [config.path];
            paths.forEach((path) => {
                declarations.push({ ...declaration, cache: config.cache, path });
            });
        }
        else {
            // With an in-source config without a path, add the config to the declaration.
            const { path, excludedPath, pattern, excludedPattern, ...rest } = config;
            declarations.push({ ...declaration, ...rest });
        }
        functionsVisited.add(declaration.function);
    }
    return declarations;
};
const createDeclarationsFromFunctionConfigs = (functionConfigs, functionsVisited) => {
    const declarations = [];
    for (const name in functionConfigs) {
        const functionConfig = functionConfigs[name];
        const { cache, method } = functionConfigs[name];
        if (!functionsVisited.has(name)) {
            // If we have a pattern specified, create a declaration for each pattern.
            if ('pattern' in functionConfig && functionConfig.pattern) {
                const { header, pattern, excludedPattern } = functionConfig;
                const patterns = Array.isArray(pattern) ? pattern : [pattern];
                patterns.forEach((singlePattern) => {
                    const declaration = { function: name, pattern: singlePattern };
                    if (cache) {
                        declaration.cache = cache;
                    }
                    if (method) {
                        declaration.method = method;
                    }
                    if (excludedPattern) {
                        declaration.excludedPattern = excludedPattern;
                    }
                    if (header) {
                        declaration.header = header;
                    }
                    declarations.push(declaration);
                });
            }
            // If we don't have a pattern but we have a path specified, create a declaration for each path.
            else if ('path' in functionConfig && functionConfig.path) {
                const { header, path, excludedPath } = functionConfig;
                const paths = Array.isArray(path) ? path : [path];
                paths.forEach((singlePath) => {
                    const declaration = { function: name, path: singlePath };
                    if (cache) {
                        declaration.cache = cache;
                    }
                    if (method) {
                        declaration.method = method;
                    }
                    if (excludedPath) {
                        declaration.excludedPath = excludedPath;
                    }
                    if (header) {
                        declaration.header = header;
                    }
                    declarations.push(declaration);
                });
            }
        }
    }
    return declarations;
};
/**
 * Normalizes a regular expression, ensuring it has a leading `^` and trailing
 * `$` characters.
 */
export const normalizePattern = (pattern) => {
    let enclosedPattern = pattern;
    if (!pattern.startsWith('^')) {
        enclosedPattern = `^${enclosedPattern}`;
    }
    if (!pattern.endsWith('$')) {
        enclosedPattern = `${enclosedPattern}$`;
    }
    const regexp = new RegExp(enclosedPattern);
    // Strip leading and forward slashes.
    return regexp.toString().slice(1, -1);
};
const headerConfigError = `The 'header' configuration property must be an object where keys are strings and values are either booleans or strings (e.g. { "x-header-present": true, "x-header-absent": false, "x-header-matching": "^prefix" }).`;
export const getHeaderMatchers = (headers) => {
    const matchers = {};
    if (!headers) {
        return matchers;
    }
    if (Object.getPrototypeOf(headers) !== Object.prototype) {
        throw new BundleError(new Error(headerConfigError));
    }
    for (const header in headers) {
        if (typeof headers[header] === 'boolean') {
            matchers[header] = { matcher: headers[header] ? 'exists' : 'missing' };
        }
        else if (typeof headers[header] === 'string') {
            // Strip leading and forward slashes.
            const pattern = new RegExp(headers[header]).toString().slice(1, -1);
            matchers[header] = { matcher: 'regex', pattern };
        }
        else {
            throw new BundleError(new Error(headerConfigError));
        }
    }
    return matchers;
};
